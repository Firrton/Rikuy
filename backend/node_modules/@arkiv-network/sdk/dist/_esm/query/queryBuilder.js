import { entityFromRpcResult } from "../utils/entities";
import { processQuery } from "./engine";
import { QueryResult } from "./queryResult";
/**
 * QueryBuilder is a helper class to build queries to the Arkiv DBChains.
 * It can be used to fetch entities from the Arkiv DBChains. It follows the Builder pattern allowing chaining of methods.
 * @param client - The Arkiv client
 * @returns The QueryBuilder instance {@link QueryBuilder}
 */
export class QueryBuilder {
    _client;
    _ownedBy;
    _validAtBlock;
    _withAttributes;
    _withMetadata;
    _withPayload;
    _limit;
    _cursor;
    _predicates;
    constructor(client) {
        this._client = client;
        this._predicates = [];
    }
    /**
     * Sets the ownedBy filter
     * @param ownedBy - The address of the owner
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.ownedBy("0x1234567890123456789012345678901234567890")
     */
    ownedBy(ownedBy) {
        this._ownedBy = ownedBy;
        return this;
    }
    /**
     * Sets the withAttributes flag which will return the attributes for the entities if true
     * @param withAttributes - The boolean value to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.withAttributes(true)
     */
    withAttributes(withAttributes = true) {
        this._withAttributes = withAttributes;
        return this;
    }
    /**
     * Sets the withMetadata flag which will return the metadata (like owner, expiredAt, etc.) for the entities if true
     * @param withMetadata - The boolean value to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.withMetadata(true)
     */
    withMetadata(withMetadata = true) {
        this._withMetadata = withMetadata;
        return this;
    }
    /**
     * Sets the withPayload flag which will return the payload for the entities if true
     * @param withPayload - The boolean value to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.withPayload(true)
     */
    withPayload(withPayload = true) {
        this._withPayload = withPayload;
        return this;
    }
    /**
     * Sets the limit for the query
     * @param limit - The number of entities to return
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.limit(10)
     */
    limit(limit) {
        this._limit = limit;
        return this;
    }
    /**
     * Sets the cursor for the query - it is advances setting which rather shouldn't be used manually but it is provided from query result if limit is used (pagination).
     * @param cursor - The cursor to set which tells to RPC Query server where to start or continue the query.
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.offset(10)
     */
    cursor(cursor) {
        this._cursor = cursor;
        return this;
    }
    /**
     * Sets the validAtBlock for the query which tells at which block height the state we are intested.
     * If not set, the latest block is  used.
     * @param validAtBlock - The block number to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.validAtBlock(10000)
     */
    validAtBlock(validAtBlock) {
        this._validAtBlock = validAtBlock;
        return this;
    }
    /**
     * Sets the predicates for the query limiting the results. It can be a single predicate or an array of predicates combined with 'and'.
     * Predicates can be nested using 'or' and 'and' predicates.
     * @param predicates - The predicates to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.where(eq("name", "John"))
     * builder.where([eq("name", "John"), eq("age", 30)])
     * builder.where([eq("name", "John"), or([eq("age", 30), eq("age", 31)])])
     * builder.where([eq("name", "John"), and([eq("age", 30), eq("age", 31)])])
     * builder.where([eq("name", "John"), or([eq("age", 30), and([eq("age", 31), eq("age", 32)])])])
     * builder.where([eq("name", "John"), and([eq("age", 30), or([eq("age", 31), eq("age", 32)])])])
     * builder.where([eq("name", "John"), and([eq("age", 30), or([eq("age", 31), and([eq("age", 32), eq("age", 33)])])])])
     */
    where(predicates) {
        if (Array.isArray(predicates)) {
            this._predicates.push(...predicates);
        }
        else {
            this._predicates.push(predicates);
        }
        return this;
    }
    /**
     * Fetches the entities from the query. Re
     * It will return a QueryResult instance which can be used to fetch the next and previous pages.
     * @returns The QueryResult instance {@link QueryResult}
     *
     * @example
     * const builder = new QueryBuilder(client)
     * const result = await builder.where(eq("name", "John")).fetch()
     * // result = { entities: [Entity, Entity, Entity], next: async () => QueryResult, previous: async () => QueryResult }
     */
    async fetch() {
        const queryResult = await processQuery(this._client, {
            predicates: this._predicates,
            limit: this._limit,
            cursor: this._cursor,
            ownedBy: this._ownedBy,
            validAtBlock: this._validAtBlock,
            withAttributes: this._withAttributes,
            withMetadata: this._withMetadata,
            withPayload: this._withPayload,
        });
        const entities = await Promise.all(queryResult.data.map((entity) => entityFromRpcResult(entity)));
        this.cursor(queryResult.cursor);
        this.validAtBlock(queryResult.blockNumber);
        return new QueryResult(entities, this, this._cursor, this._limit, this._validAtBlock);
    }
    /**
     * Counts the entities from the query.
     * @returns The number of entities
     *
     * @example
     * const builder = new QueryBuilder(client)
     * const result = await builder.where(eq("name", "John")).count()
     * // result = 10
     */
    async count() {
        const queryResult = await processQuery(this._client, {
            predicates: this._predicates,
            limit: this._limit,
            cursor: this._cursor,
            ownedBy: this._ownedBy,
            validAtBlock: this._validAtBlock,
            withAttributes: false,
            withMetadata: false,
            withPayload: false,
        });
        return queryResult.data.length ?? 0;
    }
}
//# sourceMappingURL=queryBuilder.js.map