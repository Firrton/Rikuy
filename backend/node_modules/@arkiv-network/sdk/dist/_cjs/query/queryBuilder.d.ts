import type { Hex } from "viem";
import type { ArkivClient } from "../clients/baseClient";
import type { Predicate } from "./predicate";
import { QueryResult } from "./queryResult";
/**
 * QueryBuilder is a helper class to build queries to the Arkiv DBChains.
 * It can be used to fetch entities from the Arkiv DBChains. It follows the Builder pattern allowing chaining of methods.
 * @param client - The Arkiv client
 * @returns The QueryBuilder instance {@link QueryBuilder}
 */
export declare class QueryBuilder {
    private _client;
    private _ownedBy;
    private _validAtBlock;
    private _withAttributes;
    private _withMetadata;
    private _withPayload;
    private _limit;
    private _cursor;
    private _predicates;
    constructor(client: ArkivClient);
    /**
     * Sets the ownedBy filter
     * @param ownedBy - The address of the owner
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.ownedBy("0x1234567890123456789012345678901234567890")
     */
    ownedBy(ownedBy: Hex): this;
    /**
     * Sets the withAttributes flag which will return the attributes for the entities if true
     * @param withAttributes - The boolean value to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.withAttributes(true)
     */
    withAttributes(withAttributes?: boolean): this;
    /**
     * Sets the withMetadata flag which will return the metadata (like owner, expiredAt, etc.) for the entities if true
     * @param withMetadata - The boolean value to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.withMetadata(true)
     */
    withMetadata(withMetadata?: boolean): this;
    /**
     * Sets the withPayload flag which will return the payload for the entities if true
     * @param withPayload - The boolean value to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.withPayload(true)
     */
    withPayload(withPayload?: boolean): this;
    /**
     * Sets the limit for the query
     * @param limit - The number of entities to return
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.limit(10)
     */
    limit(limit: number): this;
    /**
     * Sets the cursor for the query - it is advances setting which rather shouldn't be used manually but it is provided from query result if limit is used (pagination).
     * @param cursor - The cursor to set which tells to RPC Query server where to start or continue the query.
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.offset(10)
     */
    cursor(cursor: string): this;
    /**
     * Sets the validAtBlock for the query which tells at which block height the state we are intested.
     * If not set, the latest block is  used.
     * @param validAtBlock - The block number to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.validAtBlock(10000)
     */
    validAtBlock(validAtBlock: bigint): this;
    /**
     * Sets the predicates for the query limiting the results. It can be a single predicate or an array of predicates combined with 'and'.
     * Predicates can be nested using 'or' and 'and' predicates.
     * @param predicates - The predicates to set
     * @returns The QueryBuilder instance
     *
     * @example
     * const builder = new QueryBuilder(client)
     * builder.where(eq("name", "John"))
     * builder.where([eq("name", "John"), eq("age", 30)])
     * builder.where([eq("name", "John"), or([eq("age", 30), eq("age", 31)])])
     * builder.where([eq("name", "John"), and([eq("age", 30), eq("age", 31)])])
     * builder.where([eq("name", "John"), or([eq("age", 30), and([eq("age", 31), eq("age", 32)])])])
     * builder.where([eq("name", "John"), and([eq("age", 30), or([eq("age", 31), eq("age", 32)])])])
     * builder.where([eq("name", "John"), and([eq("age", 30), or([eq("age", 31), and([eq("age", 32), eq("age", 33)])])])])
     */
    where(predicates: Predicate[] | Predicate): this;
    /**
     * Fetches the entities from the query. Re
     * It will return a QueryResult instance which can be used to fetch the next and previous pages.
     * @returns The QueryResult instance {@link QueryResult}
     *
     * @example
     * const builder = new QueryBuilder(client)
     * const result = await builder.where(eq("name", "John")).fetch()
     * // result = { entities: [Entity, Entity, Entity], next: async () => QueryResult, previous: async () => QueryResult }
     */
    fetch(): Promise<QueryResult>;
    /**
     * Counts the entities from the query.
     * @returns The number of entities
     *
     * @example
     * const builder = new QueryBuilder(client)
     * const result = await builder.where(eq("name", "John")).count()
     * // result = 10
     */
    count(): Promise<1>;
}
//# sourceMappingURL=queryBuilder.d.ts.map